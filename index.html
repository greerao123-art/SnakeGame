<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nokia Snake Game</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            font-family: 'Courier New', monospace;
            color: white;
            touch-action: manipulation;
        }
        
        .game-container {
            text-align: center;
            background-color: rgba(52, 73, 94, 0.9);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0,0,0,0.7);
            max-width: 100vw;
            width: 100%;
            max-width: 650px;
        }
        
        canvas {
            border: 3px solid #ecf0f1;
            background-color: #1a1a1a;
            display: block;
            margin: 0 auto;
            max-width: 100%;
            height: auto;
            touch-action: none;
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-size: 16px;
            flex-wrap: wrap;
        }
        
        .status-message {
            margin: 10px 0;
            padding: 8px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 14px;
        }
        
        .food-counter {
            color: #f1c40f;
        }
        
        .door-locked {
            color: #e74c3c;
        }
        
        .door-open {
            color: #27ae60;
        }
        
        /* Modal Instructions */
        .instructions-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .instructions-content {
            background-color: #34495e;
            padding: 25px;
            border-radius: 15px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            text-align: center;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        
        .instructions-content h2 {
            color: #3498db;
            margin: 0 0 15px 0;
            font-size: 24px;
        }
        
        .instruction-item {
            margin: 12px 0;
            padding: 8px;
            text-align: left;
            font-size: 16px;
            line-height: 1.4;
        }
        
        .instruction-item strong {
            color: #3498db;
        }
        
        /* Ergonomic Mobile Controls */
        .mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            z-index: 1000;
        }
        
        .control-cross {
            position: relative;
            width: 140px;
            height: 140px;
        }
        
        .virtual-btn {
            position: absolute;
            width: 45px;
            height: 45px;
            background-color: rgba(52, 152, 219, 0.9);
            color: white;
            border: 2px solid #3498db;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            transition: all 0.1s ease;
        }
        
        .virtual-btn:active {
            background-color: rgba(41, 128, 185, 0.9);
            transform: scale(0.95);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }
        
        /* Cross layout positioning */
        .btn-up {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .btn-down {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .btn-left {
            left: 0;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .btn-right {
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .controls-label {
            color: #bdc3c7;
            font-size: 12px;
            text-align: center;
            margin-top: 5px;
        }
        
        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.95);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 20px;
            display: none;
            z-index: 1500;
            max-width: 90vw;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            touch-action: manipulation;
            transition: background-color 0.2s;
        }
        
        button:hover, button:active {
            background-color: #2980b9;
        }
        
        .ok-button {
            background-color: #27ae60;
            font-size: 18px;
            padding: 15px 30px;
            margin-top: 20px;
        }
        
        .ok-button:hover, .ok-button:active {
            background-color: #229954;
        }
        
        /* Hide mobile controls on desktop */
        @media (min-width: 768px) {
            .mobile-controls {
                display: none;
            }
        }
        
        @media (max-width: 600px) {
            canvas {
                width: 100%;
                height: 250px;
            }
            
            .game-info {
                font-size: 14px;
            }
            
            .instruction-item {
                font-size: 14px;
            }
            
            .virtual-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            
            .control-cross {
                width: 160px;
                height: 160px;
            }
        }
        
        /* Very small screens */
        @media (max-width: 400px) {
            .instructions-content {
                padding: 15px;
            }
            
            .instruction-item {
                font-size: 13px;
                margin: 8px 0;
            }
        }
    </style>
</head>
<body>
    <!-- Instructions Modal -->
    <div class="instructions-modal" id="instructionsModal">
        <div class="instructions-content">
            <h2>üêç Nokia Snake Game</h2>
            
            <div class="instruction-item">
                <strong>üéØ Objective:</strong> Eat ALL yellow food and reach the EXIT door within 60 seconds!
            </div>
            
            <div class="instruction-item">
                <strong>üü° DO:</strong> Eat yellow food circles for points (10 pts each)
            </div>
            
            <div class="instruction-item">
                <strong>‚ùå DON'T HIT:</strong> Red furry balls, gray obstacles, walls, or yourself
            </div>
            
            <div class="instruction-item">
                <strong>üö™ IMPORTANT:</strong> Door only opens when ALL food is eaten. Hitting a locked door = DEATH!
            </div>
            
            <div class="instruction-item">
                <strong>üéÆ CONTROLS:</strong> 
                <br>‚Ä¢ Desktop: Arrow keys
                <br>‚Ä¢ Mobile: Swipe on screen OR use virtual buttons at bottom
            </div>
            
            <div class="instruction-item">
                <strong>‚ö° SPECIAL:</strong> Red furry balls move around - avoid them at all costs!
            </div>
            
            <button class="ok-button" onclick="startGameFromInstructions()">
                Got it! Let's Play! üöÄ
            </button>
        </div>
    </div>

    <div class="game-container">
        <div class="game-info">
            <div>Score: <span id="score">0</span></div>
            <div class="food-counter">Food Left: <span id="foodCount">0</span></div>
            <div>Time: <span id="timer">60</span>s</div>
        </div>
        
        <div class="status-message" id="doorStatus">
            <span class="door-locked">üîí Door is LOCKED - Eat all food first!</span>
        </div>
        
        <canvas id="gameCanvas" width="600" height="400"></canvas>
        
        <div class="game-over" id="gameOver">
            <div id="gameOverText">Game Over!</div>
            <button onclick="showInstructions()">Play Again</button>
        </div>
    </div>

    <!-- Ergonomic Mobile Controls -->
    <div class="mobile-controls">
        <div class="control-cross">
            <button class="virtual-btn btn-up" id="upBtn">‚Üë</button>
            <button class="virtual-btn btn-left" id="leftBtn">‚Üê</button>
            <button class="virtual-btn btn-right" id="rightBtn">‚Üí</button>
            <button class="virtual-btn btn-down" id="downBtn">‚Üì</button>
        </div>
        <div class="controls-label">Swipe screen or use buttons</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const timerElement = document.getElementById('timer');
        const foodCountElement = document.getElementById('foodCount');
        const doorStatusElement = document.getElementById('doorStatus');
        const gameOverElement = document.getElementById('gameOver');
        const gameOverText = document.getElementById('gameOverText');
        const instructionsModal = document.getElementById('instructionsModal');

        // Mobile responsiveness
        function resizeCanvas() {
            const container = canvas.parentElement;
            const maxWidth = Math.min(600, container.clientWidth - 30);
            const maxHeight = Math.min(400, window.innerHeight * 0.4);
            
            canvas.style.width = maxWidth + 'px';
            canvas.style.height = (maxWidth * 2/3) + 'px';
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        const gridSize = 20;
        const tileCount = {
            x: canvas.width / gridSize,
            y: canvas.height / gridSize
        };

        let game = {
            snake: [],
            direction: { x: 1, y: 0 },
            food: [],
            obstacles: [],
            spikes: [],
            exitDoor: null,
            score: 0,
            timeLeft: 60,
            gameRunning: false,
            gameInterval: null,
            timerInterval: null,
            spikeInterval: null,
            doorOpen: false,
            totalFood: 0
        };

        function showInstructions() {
            instructionsModal.style.display = 'flex';
            // Pause any running game
            if (game.gameRunning) {
                game.gameRunning = false;
                clearInterval(game.gameInterval);
                clearInterval(game.timerInterval);
                clearInterval(game.spikeInterval);
            }
        }

        function startGameFromInstructions() {
            instructionsModal.style.display = 'none';
            gameOverElement.style.display = 'none';
            startGame();
        }

        function initGame() {
            // Initialize snake in the center-left
            game.snake = [
                { x: 5, y: Math.floor(tileCount.y / 2) },
                { x: 4, y: Math.floor(tileCount.y / 2) },
                { x: 3, y: Math.floor(tileCount.y / 2) }
            ];
            
            game.direction = { x: 1, y: 0 };
            game.food = [];
            game.obstacles = [];
            game.spikes = [];
            game.score = 0;
            game.timeLeft = 60;
            game.gameRunning = true;
            game.doorOpen = false;

            // Create exit door at the right side
            game.exitDoor = {
                x: tileCount.x - 2,
                y: Math.floor(tileCount.y / 2)
            };

            // Generate initial food
            generateFood();
            
            // Generate initial obstacles and spikes
            generateObstaclesAndSpikes();
            
            updateFoodCounter();
        }

        function generateFood() {
            // Generate 5-8 food items
            const foodCount = Math.floor(Math.random() * 4) + 5;
            game.totalFood = foodCount;
            
            for (let i = 0; i < foodCount; i++) {
                let newFood;
                let attempts = 0;
                do {
                    newFood = {
                        x: Math.floor(Math.random() * (tileCount.x - 4)) + 2,
                        y: Math.floor(Math.random() * (tileCount.y - 4)) + 2
                    };
                    attempts++;
                } while (isPositionOccupied(newFood.x, newFood.y) && attempts < 50);
                
                if (attempts < 50) {
                    game.food.push(newFood);
                }
            }
        }

        function generateObstaclesAndSpikes() {
            // Clear previous obstacles and spikes
            game.obstacles = [];
            game.spikes = [];
            
            // Generate varying length obstacles
            const obstacleCount = Math.floor(Math.random() * 4) + 3;
            for (let i = 0; i < obstacleCount; i++) {
                const length = Math.floor(Math.random() * 3) + 2; // 2-4 blocks long
                const horizontal = Math.random() > 0.5;
                
                let startX, startY;
                let attempts = 0;
                do {
                    startX = Math.floor(Math.random() * (tileCount.x - (horizontal ? length : 1)));
                    startY = Math.floor(Math.random() * (tileCount.y - (horizontal ? 1 : length)));
                    attempts++;
                } while (attempts < 30 && (startX < 8 || startX > tileCount.x - 8));
                
                for (let j = 0; j < length; j++) {
                    const obstacle = {
                        x: startX + (horizontal ? j : 0),
                        y: startY + (horizontal ? 0 : j)
                    };
                    
                    if (!isPositionOccupied(obstacle.x, obstacle.y)) {
                        game.obstacles.push(obstacle);
                    }
                }
            }
            
            // Generate moving spikes
            const spikeCount = Math.floor(Math.random() * 3) + 3;
            for (let i = 0; i < spikeCount; i++) {
                let newSpike;
                let attempts = 0;
                do {
                    newSpike = {
                        x: Math.floor(Math.random() * (tileCount.x - 4)) + 2,
                        y: Math.floor(Math.random() * (tileCount.y - 4)) + 2,
                        dx: (Math.random() - 0.5) * 0.1,
                        dy: (Math.random() - 0.5) * 0.1,
                        realX: 0,
                        realY: 0
                    };
                    attempts++;
                } while (isPositionOccupied(newSpike.x, newSpike.y) && attempts < 30);
                
                newSpike.realX = newSpike.x;
                newSpike.realY = newSpike.y;
                
                if (attempts < 30) {
                    game.spikes.push(newSpike);
                }
            }
        }

        function isPositionOccupied(x, y) {
            // Check if position is occupied by snake, food, obstacles, or exit
            for (let segment of game.snake) {
                if (segment.x === x && segment.y === y) return true;
            }
            for (let food of game.food) {
                if (food.x === x && food.y === y) return true;
            }
            for (let obstacle of game.obstacles) {
                if (obstacle.x === x && obstacle.y === y) return true;
            }
            if (game.exitDoor && game.exitDoor.x === x && game.exitDoor.y === y) return true;
            
            return false;
        }

        function moveSpikes() {
            for (let spike of game.spikes) {
                spike.realX += spike.dx;
                spike.realY += spike.dy;
                
                // Bounce off walls
                if (spike.realX <= 0 || spike.realX >= tileCount.x - 1) {
                    spike.dx = -spike.dx;
                    spike.realX = Math.max(0, Math.min(tileCount.x - 1, spike.realX));
                }
                if (spike.realY <= 0 || spike.realY >= tileCount.y - 1) {
                    spike.dy = -spike.dy;
                    spike.realY = Math.max(0, Math.min(tileCount.y - 1, spike.realY));
                }
                
                spike.x = Math.round(spike.realX);
                spike.y = Math.round(spike.realY);
            }
        }

        function drawGame() {
            // Clear canvas
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw snake
            ctx.fillStyle = '#27ae60';
            for (let i = 0; i < game.snake.length; i++) {
                const segment = game.snake[i];
                ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize - 2, gridSize - 2);
                
                // Draw snake head with eyes
                if (i === 0) {
                    ctx.fillStyle = '#2ecc71';
                    ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize - 2, gridSize - 2);
                    
                    // Eyes
                    ctx.fillStyle = 'black';
                    ctx.fillRect(segment.x * gridSize + 4, segment.y * gridSize + 4, 3, 3);
                    ctx.fillRect(segment.x * gridSize + 12, segment.y * gridSize + 4, 3, 3);
                    
                    ctx.fillStyle = '#27ae60';
                }
            }

            // Draw food (yellow circles)
            ctx.fillStyle = '#f1c40f';
            for (let food of game.food) {
                ctx.beginPath();
                ctx.arc(
                    food.x * gridSize + gridSize / 2,
                    food.y * gridSize + gridSize / 2,
                    gridSize / 3,
                    0,
                    2 * Math.PI
                );
                ctx.fill();
            }

            // Draw obstacles (varying length gray bars)
            ctx.fillStyle = '#7f8c8d';
            for (let obstacle of game.obstacles) {
                ctx.fillRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize - 2, gridSize - 2);
            }

            // Draw moving spikes (red furry balls)
            for (let spike of game.spikes) {
                const centerX = spike.realX * gridSize + gridSize / 2;
                const centerY = spike.realY * gridSize + gridSize / 2;
                const radius = gridSize / 3;
                
                // Draw furry effect with multiple circles
                ctx.fillStyle = '#e74c3c';
                for (let i = 0; i < 12; i++) {
                    const angle = (i * Math.PI) / 6;
                    const fuzzX = centerX + Math.cos(angle) * (radius / 2);
                    const fuzzY = centerY + Math.sin(angle) * (radius / 2);
                    
                    ctx.beginPath();
                    ctx.arc(fuzzX, fuzzY, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // Main ball
                ctx.fillStyle = '#c0392b';
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius - 2, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Draw exit door
            if (game.exitDoor) {
                const doorX = game.exitDoor.x * gridSize;
                const doorY = game.exitDoor.y * gridSize;
                
                // Door frame
                ctx.fillStyle = game.doorOpen ? '#27ae60' : '#7f8c8d';
                ctx.fillRect(doorX, doorY, gridSize - 2, gridSize - 2);
                
                // Door panels
                ctx.fillStyle = game.doorOpen ? '#2ecc71' : '#95a5a6';
                ctx.fillRect(doorX + 2, doorY + 2, (gridSize / 2) - 3, gridSize - 6);
                ctx.fillRect(doorX + (gridSize / 2) + 1, doorY + 2, (gridSize / 2) - 3, gridSize - 6);
                
                // Door handles
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(doorX + 6, doorY + gridSize/2, 2, 0, 2 * Math.PI);
                ctx.arc(doorX + gridSize - 6, doorY + gridSize/2, 2, 0, 2 * Math.PI);
                ctx.fill();
                
                // Lock/Open indicator
                ctx.fillStyle = game.doorOpen ? '#27ae60' : '#e74c3c';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(game.doorOpen ? 'OPEN' : 'LOCK', doorX + gridSize/2, doorY + gridSize - 3);
            }
        }

        function updateFoodCounter() {
            foodCountElement.textContent = game.food.length;
            
            if (game.food.length === 0) {
                game.doorOpen = true;
                doorStatusElement.innerHTML = '<span class="door-open">üîì Door is OPEN - Go to EXIT!</span>';
            } else {
                game.doorOpen = false;
                doorStatusElement.innerHTML = '<span class="door-locked">üîí Door is LOCKED - Eat all food first!</span>';
            }
        }

        function updateGame() {
            if (!game.gameRunning) return;

            // Move spikes
            moveSpikes();

            // Move snake
            const head = { ...game.snake[0] };
            head.x += game.direction.x;
            head.y += game.direction.y;

            // Check border collision
            if (head.x < 0 || head.x >= tileCount.x || head.y < 0 || head.y >= tileCount.y) {
                gameOver('Hit the border!');
                return;
            }

            // Check self collision
            for (let segment of game.snake) {
                if (head.x === segment.x && head.y === segment.y) {
                    gameOver('Hit yourself!');
                    return;
                }
            }

            // Check obstacle collision
            for (let obstacle of game.obstacles) {
                if (head.x === obstacle.x && head.y === obstacle.y) {
                    gameOver('Hit an obstacle!');
                    return;
                }
            }

            // Check spike collision
            for (let spike of game.spikes) {
                if (head.x === spike.x && head.y === spike.y) {
                    gameOver('Hit a red furry ball!');
                    return;
                }
            }

            // Check exit door
            if (game.exitDoor && head.x === game.exitDoor.x && head.y === game.exitDoor.y) {
                if (game.doorOpen) {
                    gameWin();
                    return;
                } else {
                    gameOver('Door was locked! You must eat ALL food first!');
                    return;
                }
            }

            game.snake.unshift(head);

            // Check food collision
            let foodEaten = false;
            for (let i = game.food.length - 1; i >= 0; i--) {
                if (head.x === game.food[i].x && head.y === game.food[i].y) {
                    game.food.splice(i, 1);
                    game.score += 10;
                    foodEaten = true;
                    updateFoodCounter();
                    break;
                }
            }

            if (!foodEaten) {
                game.snake.pop();
            }

            updateDisplay();
        }

        function updateDisplay() {
            scoreElement.textContent = game.score;
            timerElement.textContent = game.timeLeft;
        }

        function gameOver(reason) {
            game.gameRunning = false;
            clearInterval(game.gameInterval);
            clearInterval(game.timerInterval);
            clearInterval(game.spikeInterval);
            
            gameOverText.textContent = reason || 'Game Over!';
            gameOverElement.style.display = 'block';
        }

        function gameWin() {
            game.gameRunning = false;
            clearInterval(game.gameInterval);
            clearInterval(game.timerInterval);
            clearInterval(game.spikeInterval);
            
            gameOverText.textContent = 'You Won! üéâ Escaped through the door!';
            gameOverElement.style.display = 'block';
        }

        function startGame() {
            initGame();
            updateDisplay();
            
            game.gameInterval = setInterval(updateGame, 200);
            
            game.timerInterval = setInterval(() => {
                game.timeLeft--;
                if (game.timeLeft <= 0) {
                    gameOver('Time\'s up!');
                }
                updateDisplay();
            }, 1000);
            
            game.spikeInterval = setInterval(moveSpikes, 100);
            
            drawGame();
        }

        // Touch controls
        let touchStartX, touchStartY;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchStartX = touch.clientX - rect.left;
            touchStartY = touch.clientY - rect.top;
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (!game.gameRunning || !touchStartX || !touchStartY) return;
            
            const touch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const touchEndX = touch.clientX - rect.left;
            const touchEndY = touch.clientY - rect.top;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const minSwipeDistance = 30;
            
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (Math.abs(deltaX) > minSwipeDistance) {
                    if (deltaX > 0 && game.direction.x === 0) {
                        game.direction = { x: 1, y: 0 };
                    } else if (deltaX < 0 && game.direction.x === 0) {
                        game.direction = { x: -1, y: 0 };
                    }
                }
            } else {
                if (Math.abs(deltaY) > minSwipeDistance) {
                    if (deltaY > 0 && game.direction.y === 0) {
                        game.direction = { x: 0, y: 1 };
                    } else if (deltaY < 0 && game.direction.y === 0) {
                        game.direction = { x: 0, y: -1 };
                    }
                }
            }
            
            touchStartX = null;
            touchStartY = null;
        });

        // Virtual button controls
        document.getElementById('upBtn').addEventListener('click', () => {
            if (game.gameRunning && game.direction.y === 0) {
                game.direction = { x: 0, y: -1 };
            }
        });

        document.getElementById('downBtn').addEventListener('click', () => {
            if (game.gameRunning && game.direction.y === 0) {
                game.direction = { x: 0, y: 1 };
            }
        });

        document.getElementById('leftBtn').addEventListener('click', () => {
            if (game.gameRunning && game.direction.x === 0) {
                game.direction = { x: -1, y: 0 };
            }
        });

        document.getElementById('rightBtn').addEventListener('click', () => {
            if (game.gameRunning && game.direction.x === 0) {
                game.direction = { x: 1, y: 0 };
            }
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!game.gameRunning) return;
            
            switch (e.key) {
                case 'ArrowUp':
                    if (game.direction.y === 0) {
                        game.direction = { x: 0, y
