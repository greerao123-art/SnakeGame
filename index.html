<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nokia Snake Game</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            font-family: 'Courier New', monospace;
            color: white;
            touch-action: manipulation;
        }
        
        .game-container {
            text-align: center;
            background-color: rgba(52, 73, 94, 0.9);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0,0,0,0.7);
            max-width: 100vw;
            width: 100%;
            max-width: 650px;
            margin-bottom: 220px; /* Add space for mobile controls */
        }
        
        canvas {
            border: 3px solid #ecf0f1;
            background-color: #1a1a1a;
            display: block;
            margin: 0 auto;
            max-width: 100%;
            height: auto;
            touch-action: none;
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-size: 16px;
            flex-wrap: wrap;
        }
        
        .status-message {
            margin: 10px 0;
            padding: 8px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 14px;
        }
        
        .food-counter { color: #f1c40f; }
        .door-locked { color: #e74c3c; }
        .door-open { color: #27ae60; }
        
        .instructions-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .instructions-content {
            background-color: #34495e;
            padding: 25px;
            border-radius: 15px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            text-align: center;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        
        .instructions-content h2 {
            color: #3498db;
            margin: 0 0 15px 0;
            font-size: 24px;
        }
        
        .instruction-item {
            margin: 12px 0;
            padding: 8px;
            text-align: left;
            font-size: 16px;
            line-height: 1.4;
        }
        
        .instruction-item strong {
            color: #3498db;
        }
        
        .mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: block; /* Changed from flex to block to ensure visibility */
            z-index: 2000; /* Higher z-index to ensure it's on top */
            background-color: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #3498db;
        }
        
        .control-cross {
            position: relative;
            width: 160px;
            height: 160px;
            margin: 0 auto;
        }
        
        .virtual-btn {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: #e74c3c; /* Changed to bright red so they're easily visible */
            color: white;
            border: 3px solid #c0392b;
            border-radius: 10px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            opacity: 1; /* Ensure they're fully visible */
        }
        
        .virtual-btn:active {
            background-color: #c0392b;
            transform: scale(0.95);
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
        }
        
        .btn-up { top: 0; left: 50%; transform: translateX(-50%); }
        .btn-down { bottom: 0; left: 50%; transform: translateX(-50%); }
        .btn-left { left: 0; top: 50%; transform: translateY(-50%); }
        .btn-right { right: 0; top: 50%; transform: translateY(-50%); }
        
        .controls-label {
            color: #ecf0f1;
            font-size: 12px;
            text-align: center;
            margin-top: 10px;
            font-weight: bold;
        }
        
        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.95);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 20px;
            display: none;
            z-index: 1500;
            max-width: 90vw;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            touch-action: manipulation;
            transition: background-color 0.2s;
        }
        
        button:hover, button:active {
            background-color: #2980b9;
        }
        
        .ok-button {
            background-color: #27ae60;
            font-size: 18px;
            padding: 15px 30px;
            margin-top: 20px;
        }
        
        .ok-button:hover, .ok-button:active {
            background-color: #229954;
        }
        
        @media (min-width: 768px) {
            .mobile-controls {
                display: none;
            }
        }
        
        @media (max-width: 600px) {
            canvas {
                width: 100%;
                height: 250px;
            }
            
            .game-info {
                font-size: 14px;
            }
            
            .instruction-item {
                font-size: 14px;
            }
            
            .control-cross {
                width: 180px;
                height: 180px;
            }
            
            .virtual-btn {
                width: 55px;
                height: 55px;
                font-size: 22px;
            }
        }
        
        @media (max-width: 400px) {
            .instructions-content {
                padding: 15px;
            }
            
            .instruction-item {
                font-size: 13px;
                margin: 8px 0;
            }
        }
    </style>
</head>
<body>
    <div class="instructions-modal" id="instructionsModal">
        <div class="instructions-content">
            <h2>üêç Nokia Snake Game</h2>
            
            <div class="instruction-item">
                <strong>üéØ Objective:</strong> Eat ALL yellow food and reach the EXIT door within 60 seconds!
            </div>
            
            <div class="instruction-item">
                <strong>üü° DO:</strong> Eat yellow food circles for points (10 pts each)
            </div>
            
            <div class="instruction-item">
                <strong>‚ùå DON'T HIT:</strong> Red furry balls, gray obstacles, walls, or yourself
            </div>
            
            <div class="instruction-item">
                <strong>üö™ IMPORTANT:</strong> Door only opens when ALL food is eaten. Hitting a locked door = DEATH!
            </div>
            
            <div class="instruction-item">
                <strong>üéÆ CONTROLS:</strong> 
                <br>‚Ä¢ Desktop: Arrow keys
                <br>‚Ä¢ Mobile: Swipe on screen OR use virtual buttons at bottom
            </div>
            
            <div class="instruction-item">
                <strong>‚ö° SPECIAL:</strong> Red furry balls move around - avoid them at all costs!
            </div>
            
            <button class="ok-button" id="startGameBtn">
                Got it! Let's Play! üöÄ
            </button>
        </div>
    </div>

    <div class="game-container">
        <div class="game-info">
            <div>Score: <span id="score">0</span></div>
            <div class="food-counter">Food Left: <span id="foodCount">0</span></div>
            <div>Time: <span id="timer">60</span>s</div>
        </div>
        
        <div class="status-message" id="doorStatus">
            <span class="door-locked">üîí Door is LOCKED - Eat all food first!</span>
        </div>
        
        <canvas id="gameCanvas" width="600" height="400"></canvas>
        
        <div class="game-over" id="gameOver">
            <div id="gameOverText">Game Over!</div>
            <button id="playAgainBtn">Play Again</button>
        </div>
    </div>

    <div class="mobile-controls">
        <div class="control-cross">
            <button class="virtual-btn btn-up" id="upBtn">‚Üë</button>
            <button class="virtual-btn btn-left" id="leftBtn">‚Üê</button>
            <button class="virtual-btn btn-right" id="rightBtn">‚Üí</button>
            <button class="virtual-btn btn-down" id="downBtn">‚Üì</button>
        </div>
        <div class="controls-label">Swipe screen or use buttons</div>
    </div>

    <script>
        // Game setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 20;
        const tileCount = { x: canvas.width / gridSize, y: canvas.height / gridSize };
        
        // Game state
        let game = {
            snake: [],
            direction: { x: 1, y: 0 },
            food: [],
            obstacles: [],
            spikes: [],
            exitDoor: null,
            score: 0,
            timeLeft: 60,
            gameRunning: false,
            gameInterval: null,
            timerInterval: null,
            spikeInterval: null,
            doorOpen: false
        };
        
        // DOM elements
        const elements = {
            score: document.getElementById('score'),
            timer: document.getElementById('timer'),
            foodCount: document.getElementById('foodCount'),
            doorStatus: document.getElementById('doorStatus'),
            gameOver: document.getElementById('gameOver'),
            gameOverText: document.getElementById('gameOverText'),
            instructionsModal: document.getElementById('instructionsModal'),
            startGameBtn: document.getElementById('startGameBtn'),
            playAgainBtn: document.getElementById('playAgainBtn')
        };
        
        // Mobile responsiveness
        function resizeCanvas() {
            const container = canvas.parentElement;
            const maxWidth = Math.min(600, container.clientWidth - 30);
            canvas.style.width = maxWidth + 'px';
            canvas.style.height = (maxWidth * 2/3) + 'px';
        }
        
        // Initialize game
        function initGame() {
            game.snake = [
                { x: 5, y: Math.floor(tileCount.y / 2) },
                { x: 4, y: Math.floor(tileCount.y / 2) },
                { x: 3, y: Math.floor(tileCount.y / 2) }
            ];
            game.direction = { x: 1, y: 0 };
            game.food = [];
            game.obstacles = [];
            game.spikes = [];
            game.score = 0;
            game.timeLeft = 60;
            game.gameRunning = true;
            game.doorOpen = false;
            game.exitDoor = { x: tileCount.x - 2, y: Math.floor(tileCount.y / 2) };
            
            generateFood();
            generateObstaclesAndSpikes();
            updateFoodCounter();
        }
        
        // Generate food
        function generateFood() {
            const foodCount = Math.floor(Math.random() * 4) + 5;
            for (let i = 0; i < foodCount; i++) {
                let newFood;
                let attempts = 0;
                do {
                    newFood = {
                        x: Math.floor(Math.random() * (tileCount.x - 4)) + 2,
                        y: Math.floor(Math.random() * (tileCount.y - 4)) + 2
                    };
                    attempts++;
                } while (isPositionOccupied(newFood.x, newFood.y) && attempts < 50);
                
                if (attempts < 50) game.food.push(newFood);
            }
        }
        
        // Generate obstacles and spikes
        function generateObstaclesAndSpikes() {
            game.obstacles = [];
            game.spikes = [];
            
            // Obstacles
            const obstacleCount = Math.floor(Math.random() * 4) + 3;
            for (let i = 0; i < obstacleCount; i++) {
                const length = Math.floor(Math.random() * 3) + 2;
                const horizontal = Math.random() > 0.5;
                let startX = Math.floor(Math.random() * (tileCount.x - (horizontal ? length : 1)));
                let startY = Math.floor(Math.random() * (tileCount.y - (horizontal ? 1 : length)));
                
                for (let j = 0; j < length; j++) {
                    const obstacle = {
                        x: startX + (horizontal ? j : 0),
                        y: startY + (horizontal ? 0 : j)
                    };
                    if (!isPositionOccupied(obstacle.x, obstacle.y)) {
                        game.obstacles.push(obstacle);
                    }
                }
            }
            
            // Spikes
            const spikeCount = Math.floor(Math.random() * 3) + 3;
            for (let i = 0; i < spikeCount; i++) {
                let newSpike;
                let attempts = 0;
                do {
                    newSpike = {
                        x: Math.floor(Math.random() * (tileCount.x - 4)) + 2,
                        y: Math.floor(Math.random() * (tileCount.y - 4)) + 2,
                        dx: (Math.random() - 0.5) * 0.1,
                        dy: (Math.random() - 0.5) * 0.1,
                        realX: 0,
                        realY: 0
                    };
                    attempts++;
                } while (isPositionOccupied(newSpike.x, newSpike.y) && attempts < 30);
                
                newSpike.realX = newSpike.x;
                newSpike.realY = newSpike.y;
                if (attempts < 30) game.spikes.push(newSpike);
            }
        }
        
        // Check if position occupied
        function isPositionOccupied(x, y) {
            return game.snake.some(s => s.x === x && s.y === y) ||
                   game.food.some(f => f.x === x && f.y === y) ||
                   game.obstacles.some(o => o.x === x && o.y === y) ||
                   (game.exitDoor && game.exitDoor.x === x && game.exitDoor.y === y);
        }
        
        // Move spikes
        function moveSpikes() {
            for (let spike of game.spikes) {
                spike.realX += spike.dx;
                spike.realY += spike.dy;
                
                if (spike.realX <= 0 || spike.realX >= tileCount.x - 1) {
                    spike.dx = -spike.dx;
                    spike.realX = Math.max(0, Math.min(tileCount.x - 1, spike.realX));
                }
                if (spike.realY <= 0 || spike.realY >= tileCount.y - 1) {
                    spike.dy = -spike.dy;
                    spike.realY = Math.max(0, Math.min(tileCount.y - 1, spike.realY));
                }
                
                spike.x = Math.round(spike.realX);
                spike.y = Math.round(spike.realY);
            }
        }
        
        // Draw game
        function drawGame() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Snake
            for (let i = 0; i < game.snake.length; i++) {
                const segment = game.snake[i];
                ctx.fillStyle = i === 0 ? '#2ecc71' : '#27ae60';
                ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize - 2, gridSize - 2);
                
                if (i === 0) {
                    ctx.fillStyle = 'black';
                    ctx.fillRect(segment.x * gridSize + 4, segment.y * gridSize + 4, 3, 3);
                    ctx.fillRect(segment.x * gridSize + 12, segment.y * gridSize + 4, 3, 3);
                }
            }

            // Food
            ctx.fillStyle = '#f1c40f';
            for (let food of game.food) {
                ctx.beginPath();
                ctx.arc(food.x * gridSize + gridSize / 2, food.y * gridSize + gridSize / 2, gridSize / 3, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Obstacles
            ctx.fillStyle = '#7f8c8d';
            for (let obstacle of game.obstacles) {
                ctx.fillRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize - 2, gridSize - 2);
            }

            // Spikes
            for (let spike of game.spikes) {
                const centerX = spike.realX * gridSize + gridSize / 2;
                const centerY = spike.realY * gridSize + gridSize / 2;
                const radius = gridSize / 3;
                
                ctx.fillStyle = '#e74c3c';
                for (let i = 0; i < 12; i++) {
                    const angle = (i * Math.PI) / 6;
                    const fuzzX = centerX + Math.cos(angle) * (radius / 2);
                    const fuzzY = centerY + Math.sin(angle) * (radius / 2);
                    ctx.beginPath();
                    ctx.arc(fuzzX, fuzzY, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                ctx.fillStyle = '#c0392b';
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius - 2, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Exit door
            if (game.exitDoor) {
                const doorX = game.exitDoor.x * gridSize;
                const doorY = game.exitDoor.y * gridSize;
                
                ctx.fillStyle = game.doorOpen ? '#27ae60' : '#7f8c8d';
                ctx.fillRect(doorX, doorY, gridSize - 2, gridSize - 2);
                
                ctx.fillStyle = game.doorOpen ? '#2ecc71' : '#95a5a6';
                ctx.fillRect(doorX + 2, doorY + 2, (gridSize / 2) - 3, gridSize - 6);
                ctx.fillRect(doorX + (gridSize / 2) + 1, doorY + 2, (gridSize / 2) - 3, gridSize - 6);
                
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(doorX + 6, doorY + gridSize/2, 2, 0, 2 * Math.PI);
                ctx.arc(doorX + gridSize - 6, doorY + gridSize/2, 2, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = game.doorOpen ? '#27ae60' : '#e74c3c';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(game.doorOpen ? 'OPEN' : 'LOCK', doorX + gridSize/2, doorY + gridSize - 3);
            }
        }
        
        // Update food counter
        function updateFoodCounter() {
            elements.foodCount.textContent = game.food.length;
            if (game.food.length === 0) {
                game.doorOpen = true;
                elements.doorStatus.innerHTML = '<span class="door-open">üîì Door is OPEN - Go to EXIT!</span>';
            } else {
                game.doorOpen = false;
                elements.doorStatus.innerHTML = '<span class="door-locked">üîí Door is LOCKED - Eat all food first!</span>';
            }
        }
        
        // Update game
        function updateGame() {
            if (!game.gameRunning) return;

            moveSpikes();

            const head = { ...game.snake[0] };
            head.x += game.direction.x;
            head.y += game.direction.y;

            // Collision checks
            if (head.x < 0 || head.x >= tileCount.x || head.y < 0 || head.y >= tileCount.y) {
                return gameOver('Hit the border!');
            }

            if (game.snake.some(segment => head.x === segment.x && head.y === segment.y)) {
                return gameOver('Hit yourself!');
            }

            if (game.obstacles.some(obstacle => head.x === obstacle.x && head.y === obstacle.y)) {
                return gameOver('Hit an obstacle!');
            }

            if (game.spikes.some(spike => head.x === spike.x && head.y === spike.y)) {
                return gameOver('Hit a red furry ball!');
            }

            if (game.exitDoor && head.x === game.exitDoor.x && head.y === game.exitDoor.y) {
                return game.doorOpen ? gameWin() : gameOver('Door was locked! You must eat ALL food first!');
            }

            game.snake.unshift(head);

            // Food collision
            let foodEaten = false;
            for (let i = game.food.length - 1; i >= 0; i--) {
                if (head.x === game.food[i].x && head.y === game.food[i].y) {
                    game.food.splice(i, 1);
                    game.score += 10;
                    foodEaten = true;
                    updateFoodCounter();
                    break;
                }
            }

            if (!foodEaten) game.snake.pop();
            updateDisplay();
        }
        
        // Update display
        function updateDisplay() {
            elements.score.textContent = game.score;
            elements.timer.textContent = game.timeLeft;
        }
        
        // Game over
        function gameOver(reason) {
            game.gameRunning = false;
            clearInterval(game.gameInterval);
            clearInterval(game.timerInterval);
            clearInterval(game.spikeInterval);
            elements.gameOverText.textContent = reason || 'Game Over!';
            elements.gameOver.style.display = 'block';
        }
        
        // Game win
        function gameWin() {
            game.gameRunning = false;
            clearInterval(game.gameInterval);
            clearInterval(game.timerInterval);
            clearInterval(game.spikeInterval);
            elements.gameOverText.textContent = 'You Won! üéâ Escaped through the door!';
            elements.gameOver.style.display = 'block';
        }
        
        // Start game
        function startGame() {
            initGame();
            updateDisplay();
            game.gameInterval = setInterval(updateGame, 200);
            game.timerInterval = setInterval(() => {
                game.timeLeft--;
                if (game.timeLeft <= 0) gameOver('Time\'s up!');
                updateDisplay();
            }, 1000);
            game.spikeInterval = setInterval(moveSpikes, 100);
        }
        
        // Show instructions
        function showInstructions() {
            elements.instructionsModal.style.display = 'flex';
            if (game.gameRunning) {
                game.gameRunning = false;
                clearInterval(game.gameInterval);
                clearInterval(game.timerInterval);
                clearInterval(game.spikeInterval);
            }
        }
        
        // Start from instructions
        function startFromInstructions() {
            elements.instructionsModal.style.display = 'none';
            elements.gameOver.style.display = 'none';
            startGame();
        }
        
        // Touch controls
        let touchStartX, touchStartY;
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchStartX = touch.clientX - rect.left;
            touchStartY = touch.clientY - rect.top;
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (!game.gameRunning || !touchStartX || !touchStartY) return;
            
            const touch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const deltaX = (touch.clientX - rect.left) - touchStartX;
            const deltaY = (touch.clientY - rect.top) - touchStartY;
            const minDistance = 30;
            
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minDistance) {
                if (deltaX > 0 && game.direction.x === 0) game.direction = { x: 1, y: 0 };
                else if (deltaX < 0 && game.direction.x === 0) game.direction = { x: -1, y: 0 };
            } else if (Math.abs(deltaY) > minDistance) {
                if (deltaY > 0 && game.direction.y === 0) game.direction = { x: 0, y: 1 };
                else if (deltaY < 0 && game.direction.y === 0) game.direction = { x: 0, y: -1 };
            }
            
            touchStartX = null;
            touchStartY = null;
        });
        
        // Virtual controls
        document.getElementById('upBtn').addEventListener('click', () => {
            if (game.gameRunning && game.direction.y === 0) game.direction = { x: 0, y: -1 };
        });
        document.getElementById('downBtn').addEventListener('click', () => {
            if (game.gameRunning && game.direction.y === 0) game.direction = { x: 0, y: 1 };
        });
        document.getElementById('leftBtn').addEventListener('click', () => {
            if (game.gameRunning && game.direction.x === 0) game.direction = { x: -1, y: 0 };
        });
        document.getElementById('rightBtn').addEventListener('click', () => {
            if (game.gameRunning && game.direction.x === 0) game.direction = { x: 1, y: 0 };
        });
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            // Prevent default behavior for arrow keys to stop page scrolling
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
            
            if (!game.gameRunning) return;
            
            switch (e.key) {
                case 'ArrowUp': 
                    if (game.direction.y === 0) game.direction = { x: 0, y: -1 }; 
                    break;
                case 'ArrowDown': 
                    if (game.direction.y === 0) game.direction = { x: 0, y: 1 }; 
                    break;
                case 'ArrowLeft': 
                    if (game.direction.x === 0) game.direction = { x: -1, y: 0 }; 
                    break;
                case 'ArrowRight': 
                    if (game.direction.x === 0) game.direction = { x: 1, y: 0 }; 
                    break;
            }
        });
        
        // Game loop
        function gameLoop() {
            drawGame();
            requestAnimationFrame(gameLoop);
        }
        
        // Event listeners
        elements.startGameBtn.addEventListener('click', startFromInstructions);
        elements.playAgainBtn.addEventListener('click', showInstructions);
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('load', () => {
            resizeCanvas();
            showInstructions();
            gameLoop();
        });
    </script>
</body>
</html>
