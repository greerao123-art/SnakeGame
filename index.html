<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #fff;
            padding: 20px;
        }
        
        #game-container {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        #game-header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
        }
        
        #stats {
            display: flex;
            gap: 20px;
        }
        
        #game-canvas {
            background-color: #0f3460;
            border: 3px solid #e94560;
            border-radius: 10px;
            width: 100%;
            max-width: 800px;
            aspect-ratio: 16/9;
        }
        
        #controls {
            display: grid;
            grid-template-areas: 
                ". up ."
                "left down right";
            gap: 10px;
            margin-top: 10px;
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #fff;
            border-radius: 10px;
            color: white;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .control-btn:active {
            background: rgba(255, 255, 255, 0.4);
        }
        
        #up { grid-area: up; }
        #left { grid-area: left; }
        #down { grid-area: down; }
        #right { grid-area: right; }
        
        #instructions, #speed-selection, #game-over {
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            max-width: 600px;
            width: 100%;
        }
        
        h1 {
            color: #e94560;
            margin-bottom: 20px;
        }
        
        h2 {
            color: #4cc9f0;
            margin-bottom: 15px;
        }
        
        ul {
            text-align: left;
            margin: 15px 0;
            padding-left: 20px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        .btn {
            background: linear-gradient(to right, #e94560, #f72585);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 50px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px 5px;
            transition: all 0.3s;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(233, 69, 96, 0.4);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .speed-btn {
            background: linear-gradient(to right, #4361ee, #4cc9f0);
        }
        
        .hidden {
            display: none;
        }
        
        #death-reason {
            color: #e94560;
            font-weight: bold;
            margin: 15px 0;
            font-size: 18px;
        }
        
        @media (max-width: 600px) {
            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            
            #game-header {
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="instructions">
            <h1>Snake Game</h1>
            <h2>Instructions</h2>
            <ul>
                <li>Game lasts for 2 minutes</li>
                <li>Eat all 10 yellow food items to grow longer</li>
                <li>Exit through the door only after eating all food</li>
                <li>Avoid red crabs - they move and will kill you</li>
                <li>Avoid grey brick obstacles</li>
                <li>Don't hit the exit door before eating all food</li>
                <li>Don't collide with yourself</li>
                <li>Use arrow keys or the virtual buttons to control the snake</li>
            </ul>
            <button id="start-btn" class="btn">Start Game</button>
        </div>

        <div id="speed-selection" class="hidden">
            <h2>Select Snake Speed</h2>
            <button id="slow-btn" class="btn speed-btn">Slow</button>
            <button id="medium-btn" class="btn speed-btn">Medium</button>
            <button id="fast-btn" class="btn speed-btn">Fast</button>
        </div>

        <div id="game-header" class="hidden">
            <div id="stats">
                <div>Food: <span id="food-count">0</span>/10</div>
                <div>Time: <span id="timer">02:00</span></div>
                <div>Score: <span id="score">0</span></div>
            </div>
        </div>

        <canvas id="game-canvas" class="hidden"></canvas>

        <div id="controls" class="hidden">
            <button id="up" class="control-btn">↑</button>
            <button id="left" class="control-btn">←</button>
            <button id="down" class="control-btn">↓</button>
            <button id="right" class="control-btn">→</button>
        </div>

        <div id="game-over" class="hidden">
            <h2>Game Over</h2>
            <p id="death-reason"></p>
            <p>Final Score: <span id="final-score">0</span></p>
            <button id="play-again-btn" class="btn">Play Again</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game elements
            const instructions = document.getElementById('instructions');
            const speedSelection = document.getElementById('speed-selection');
            const gameHeader = document.getElementById('game-header');
            const gameCanvas = document.getElementById('game-canvas');
            const controls = document.getElementById('controls');
            const gameOver = document.getElementById('game-over');
            
            // Buttons
            const startBtn = document.getElementById('start-btn');
            const slowBtn = document.getElementById('slow-btn');
            const mediumBtn = document.getElementById('medium-btn');
            const fastBtn = document.getElementById('fast-btn');
            const playAgainBtn = document.getElementById('play-again-btn');
            
            // Control buttons
            const upBtn = document.getElementById('up');
            const leftBtn = document.getElementById('left');
            const downBtn = document.getElementById('down');
            const rightBtn = document.getElementById('right');
            
            // Stats elements
            const foodCount = document.getElementById('food-count');
            const timerElement = document.getElementById('timer');
            const scoreElement = document.getElementById('score');
            const finalScoreElement = document.getElementById('final-score');
            const deathReasonElement = document.getElementById('death-reason');
            
            // Canvas context
            const ctx = gameCanvas.getContext('2d');
            
            // Game variables
            let snake = [];
            let food = [];
            let crabs = [];
            let obstacles = [];
            let exitDoor = null;
            let direction = 'right';
            let nextDirection = 'right';
            let gameInterval = null;
            let crabMoveInterval = null;
            let timerInterval = null;
            let gameSpeed = 150; // milliseconds
            let foodEaten = 0;
            let score = 0;
            let gameTime = 120; // 2 minutes in seconds
            let cellSize = 20;
            let gridWidth = 0;
            let gridHeight = 0;
            let gameRunning = false;
            
            // Initialize game canvas size
            function initCanvas() {
                // Set canvas size based on container, maintaining aspect ratio
                const containerWidth = gameCanvas.parentElement.clientWidth;
                const calculatedHeight = containerWidth * (9/16);
                
                gameCanvas.width = containerWidth;
                gameCanvas.height = calculatedHeight;
                
                // Calculate cell size based on canvas width (approx 40 cells wide)
                cellSize = Math.floor(containerWidth / 40);
                gridWidth = Math.floor(gameCanvas.width / cellSize);
                gridHeight = Math.floor(gameCanvas.height / cellSize);
            }
            
            // Initialize game objects
            function initGame() {
                // Initialize snake in the middle of the grid
                const startX = Math.floor(gridWidth / 4);
                const startY = Math.floor(gridHeight / 2);
                snake = [
                    {x: startX, y: startY},
                    {x: startX - 1, y: startY},
                    {x: startX - 2, y: startY}
                ];
                
                // Create exactly 10 food items
                food = [];
                for (let i = 0; i < 10; i++) {
                    addFood();
                }
                
                // Create crabs (3 crabs)
                crabs = [];
                for (let i = 0; i < 3; i++) {
                    addCrab();
                }
                
                // Create obstacles (5-7 obstacles)
                obstacles = [];
                createObstacles();
                
                // Create exit door on the right side
                const doorY = Math.floor(gridHeight / 2);
                exitDoor = {x: gridWidth - 2, y: doorY, width: 1, height: 3};
                
                // Reset game state
                direction = 'right';
                nextDirection = 'right';
                foodEaten = 0;
                score = 0;
                gameTime = 120;
                
                // Update UI
                foodCount.textContent = '0';
                scoreElement.textContent = '0';
                timerElement.textContent = '02:00';
                
                // Draw initial game state
                draw();
            }
            
            // Add a new food item at a random position
            function addFood() {
                let newFood;
                let overlapping;
                
                do {
                    overlapping = false;
                    newFood = {
                        x: Math.floor(Math.random() * (gridWidth - 4)) + 2,
                        y: Math.floor(Math.random() * (gridHeight - 4)) + 2
                    };
                    
                    // Check if overlapping with snake
                    for (let segment of snake) {
                        if (segment.x === newFood.x && segment.y === newFood.y) {
                            overlapping = true;
                            break;
                        }
                    }
                    
                    // Check if overlapping with existing food
                    for (let f of food) {
                        if (f.x === newFood.x && f.y === newFood.y) {
                            overlapping = true;
                            break;
                        }
                    }
                    
                    // Check if overlapping with obstacles
                    for (let obstacle of obstacles) {
                        for (let x = obstacle.x; x < obstacle.x + obstacle.width; x++) {
                            for (let y = obstacle.y; y < obstacle.y + obstacle.height; y++) {
                                if (x === newFood.x && y === newFood.y) {
                                    overlapping = true;
                                    break;
                                }
                            }
                            if (overlapping) break;
                        }
                        if (overlapping) break;
                    }
                    
                    // Check if overlapping with exit door
                    if (exitDoor) {
                        for (let x = exitDoor.x; x < exitDoor.x + exitDoor.width; x++) {
                            for (let y = exitDoor.y; y < exitDoor.y + exitDoor.height; y++) {
                                if (x === newFood.x && y === newFood.y) {
                                    overlapping = true;
                                    break;
                                }
                            }
                            if (overlapping) break;
                        }
                    }
                    
                } while (overlapping);
                
                food.push(newFood);
            }
            
            // Add a new crab at a random position
            function addCrab() {
                let newCrab;
                let overlapping;
                
                do {
                    overlapping = false;
                    newCrab = {
                        x: Math.floor(Math.random() * (gridWidth - 6)) + 3,
                        y: Math.floor(Math.random() * (gridHeight - 6)) + 3,
                        direction: ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)]
                    };
                    
                    // Check if overlapping with snake
                    for (let segment of snake) {
                        if (segment.x === newCrab.x && segment.y === newCrab.y) {
                            overlapping = true;
                            break;
                        }
                    }
                    
                    // Check if overlapping with food
                    for (let f of food) {
                        if (f.x === newCrab.x && f.y === newCrab.y) {
                            overlapping = true;
                            break;
                        }
                    }
                    
                    // Check if overlapping with obstacles
                    for (let obstacle of obstacles) {
                        for (let x = obstacle.x; x < obstacle.x + obstacle.width; x++) {
                            for (let y = obstacle.y; y < obstacle.y + obstacle.height; y++) {
                                if (x === newCrab.x && y === newCrab.y) {
                                    overlapping = true;
                                    break;
                                }
                            }
                            if (overlapping) break;
                        }
                        if (overlapping) break;
                    }
                    
                    // Check if overlapping with exit door
                    if (exitDoor) {
                        for (let x = exitDoor.x; x < exitDoor.x + exitDoor.width; x++) {
                            for (let y = exitDoor.y; y < exitDoor.y + exitDoor.height; y++) {
                                if (x === newCrab.x && y === newCrab.y) {
                                    overlapping = true;
                                    break;
                                }
                            }
                            if (overlapping) break;
                        }
                    }
                    
                    // Check if overlapping with other crabs
                    for (let crab of crabs) {
                        if (crab.x === newCrab.x && crab.y === newCrab.y) {
                            overlapping = true;
                            break;
                        }
                    }
                    
                } while (overlapping);
                
                crabs.push(newCrab);
            }
            
            // Create obstacles in the game
            function createObstacles() {
                // Create 5-7 obstacles of varying sizes
                const numObstacles = 5 + Math.floor(Math.random() * 3);
                
                for (let i = 0; i < numObstacles; i++) {
                    let newObstacle;
                    let overlapping;
                    
                    do {
                        overlapping = false;
                        const width = 1 + Math.floor(Math.random() * 4);
                        const height = 1 + Math.floor(Math.random() * 3);
                        
                        newObstacle = {
                            x: Math.floor(Math.random() * (gridWidth - width - 4)) + 2,
                            y: Math.floor(Math.random() * (gridHeight - height - 4)) + 2,
                            width: width,
                            height: height
                        };
                        
                        // Check if overlapping with snake
                        for (let segment of snake) {
                            if (segment.x >= newObstacle.x && segment.x < newObstacle.x + newObstacle.width &&
                                segment.y >= newObstacle.y && segment.y < newObstacle.y + newObstacle.height) {
                                overlapping = true;
                                break;
                            }
                        }
                        
                        // Check if overlapping with food
                        for (let f of food) {
                            if (f.x >= newObstacle.x && f.x < newObstacle.x + newObstacle.width &&
                                f.y >= newObstacle.y && f.y < newObstacle.y + newObstacle.height) {
                                overlapping = true;
                                break;
                            }
                        }
                        
                        // Check if overlapping with exit door
                        if (exitDoor) {
                            if (newObstacle.x < exitDoor.x + exitDoor.width &&
                                newObstacle.x + newObstacle.width > exitDoor.x &&
                                newObstacle.y < exitDoor.y + exitDoor.height &&
                                newObstacle.y + newObstacle.height > exitDoor.y) {
                                overlapping = true;
                            }
                        }
                        
                        // Check if overlapping with other obstacles
                        for (let obstacle of obstacles) {
                            if (newObstacle.x < obstacle.x + obstacle.width &&
                                newObstacle.x + newObstacle.width > obstacle.x &&
                                newObstacle.y < obstacle.y + obstacle.height &&
                                newObstacle.y + newObstacle.height > obstacle.y) {
                                overlapping = true;
                                break;
                            }
                        }
                        
                    } while (overlapping);
                    
                    obstacles.push(newObstacle);
                }
            }
            
            // Move crabs randomly
            function moveCrabs() {
                for (let crab of crabs) {
                    // Occasionally change direction (about 30% of the time)
                    if (Math.random() < 0.3) {
                        crab.direction = ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)];
                    }
                    
                    let newX = crab.x;
                    let newY = crab.y;
                    
                    switch (crab.direction) {
                        case 'up': newY--; break;
                        case 'down': newY++; break;
                        case 'left': newX--; break;
                        case 'right': newX++; break;
                    }
                    
                    // Check if the new position is valid
                    let canMove = true;
                    
                    // Check boundaries
                    if (newX < 0 || newX >= gridWidth || newY < 0 || newY >= gridHeight) {
                        canMove = false;
                    }
                    
                    // Check obstacles
                    for (let obstacle of obstacles) {
                        if (newX >= obstacle.x && newX < obstacle.x + obstacle.width &&
                            newY >= obstacle.y && newY < obstacle.y + obstacle.height) {
                            canMove = false;
                            break;
                        }
                    }
                    
                    // Check exit door
                    if (exitDoor) {
                        if (newX >= exitDoor.x && newX < exitDoor.x + exitDoor.width &&
                            newY >= exitDoor.y && newY < exitDoor.y + exitDoor.height) {
                            canMove = false;
                        }
                    }
                    
                    // Check other crabs
                    for (let otherCrab of crabs) {
                        if (otherCrab !== crab && otherCrab.x === newX && otherCrab.y === newY) {
                            canMove = false;
                            break;
                        }
                    }
                    
                    // Move if possible
                    if (canMove) {
                        crab.x = newX;
                        crab.y = newY;
                    } else {
                        // Change direction if can't move
                        crab.direction = ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)];
                    }
                }
            }
            
            // Main game update function
            function update() {
                // Update direction
                direction = nextDirection;
                
                // Calculate new head position
                const head = {...snake[0]};
                
                switch (direction) {
                    case 'up': head.y--; break;
                    case 'down': head.y++; break;
                    case 'left': head.x--; break;
                    case 'right': head.x++; break;
                }
                
                // Check for game over conditions
                // 1. Hit wall
                if (head.x < 0 || head.x >= gridWidth || head.y < 0 || head.y >= gridHeight) {
                    endGame("You hit the wall!");
                    return;
                }
                
                // 2. Hit self
                for (let i = 0; i < snake.length; i++) {
                    if (snake[i].x === head.x && snake[i].y === head.y) {
                        endGame("You collided with yourself!");
                        return;
                    }
                }
                
                // 3. Hit obstacle
                for (let obstacle of obstacles) {
                    if (head.x >= obstacle.x && head.x < obstacle.x + obstacle.width &&
                        head.y >= obstacle.y && head.y < obstacle.y + obstacle.height) {
                        endGame("You hit an obstacle!");
                        return;
                    }
                }
                
                // 4. Hit crab
                for (let crab of crabs) {
                    if (head.x === crab.x && head.y === crab.y) {
                        endGame("A crab got you!");
                        return;
                    }
                }
                
                // 5. Hit exit door without eating all food
                if (exitDoor) {
                    if (head.x >= exitDoor.x && head.x < exitDoor.x + exitDoor.width &&
                        head.y >= exitDoor.y && head.y < exitDoor.y + exitDoor.height) {
                        if (foodEaten < 10) {
                            endGame("You exited before eating all food!");
                            return;
                        } else {
                            // Win condition
                            score += 500; // Bonus for winning
                            endGame("You won! All food eaten and exited safely!", true);
                            return;
                        }
                    }
                }
                
                // Check if food eaten
                let ateFood = false;
                for (let i = 0; i < food.length; i++) {
                    if (head.x === food[i].x && head.y === food[i].y) {
                        // Remove the food (no new food is added)
                        food.splice(i, 1);
                        ateFood = true;
                        foodEaten++;
                        score += 100;
                        break;
                    }
                }
                
                // Move snake
                if (ateFood) {
                    // Add new head without removing tail (snake grows)
                    snake.unshift(head);
                } else {
                    // Add new head and remove tail
                    snake.unshift(head);
                    snake.pop();
                }
                
                // Update UI
                foodCount.textContent = foodEaten;
                scoreElement.textContent = score;
                
                // Draw updated game state
                draw();
            }
            
            // Draw the game
            function draw() {
                // Clear canvas
                ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
                
                // Draw background grid
                ctx.fillStyle = '#0f3460';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                
                // Draw snake
                for (let i = 0; i < snake.length; i++) {
                    const segment = snake[i];
                    ctx.fillStyle = i === 0 ? '#4cc9f0' : '#4361ee';
                    ctx.fillRect(
                        segment.x * cellSize, 
                        segment.y * cellSize, 
                        cellSize, 
                        cellSize
                    );
                    
                    // Draw snake border
                    ctx.strokeStyle = '#1a1a2e';
                    ctx.strokeRect(
                        segment.x * cellSize, 
                        segment.y * cellSize, 
                        cellSize, 
                        cellSize
                    );
                }
                
                // Draw food
                for (let f of food) {
                    ctx.fillStyle = '#ffdd00';
                    ctx.beginPath();
                    ctx.arc(
                        f.x * cellSize + cellSize/2,
                        f.y * cellSize + cellSize/2,
                        cellSize/2 - 2,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }
                
                // Draw crabs
                for (let crab of crabs) {
                    ctx.fillStyle = '#e94560';
                    ctx.beginPath();
                    ctx.arc(
                        crab.x * cellSize + cellSize/2,
                        crab.y * cellSize + cellSize/2,
                        cellSize/2 - 2,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                    
                    // Draw legs
                    ctx.strokeStyle = '#e94560';
                    ctx.lineWidth = 2;
                    
                    // Top left leg
                    ctx.beginPath();
                    ctx.moveTo(crab.x * cellSize + cellSize/2, crab.y * cellSize + cellSize/2);
                    ctx.lineTo(crab.x * cellSize, crab.y * cellSize);
                    ctx.stroke();
                    
                    // Top right leg
                    ctx.beginPath();
                    ctx.moveTo(crab.x * cellSize + cellSize/2, crab.y * cellSize + cellSize/2);
                    ctx.lineTo(crab.x * cellSize + cellSize, crab.y * cellSize);
                    ctx.stroke();
                    
                    // Bottom left leg
                    ctx.beginPath();
                    ctx.moveTo(crab.x * cellSize + cellSize/2, crab.y * cellSize + cellSize/2);
                    ctx.lineTo(crab.x * cellSize, crab.y * cellSize + cellSize);
                    ctx.stroke();
                    
                    // Bottom right leg
                    ctx.beginPath();
                    ctx.moveTo(crab.x * cellSize + cellSize/2, crab.y * cellSize + cellSize/2);
                    ctx.lineTo(crab.x * cellSize + cellSize, crab.y * cellSize + cellSize);
                    ctx.stroke();
                }
                
                // Draw obstacles
                for (let obstacle of obstacles) {
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillRect(
                        obstacle.x * cellSize,
                        obstacle.y * cellSize,
                        obstacle.width * cellSize,
                        obstacle.height * cellSize
                    );
                    
                    // Draw brick patterns
                    ctx.strokeStyle = '#2c3e50';
                    ctx.lineWidth = 1;
                    
                    for (let x = 0; x < obstacle.width; x++) {
                        for (let y = 0; y < obstacle.height; y++) {
                            ctx.strokeRect(
                                (obstacle.x + x) * cellSize,
                                (obstacle.y + y) * cellSize,
                                cellSize,
                                cellSize
                            );
                        }
                    }
                }
                
                // Draw exit door
                if (exitDoor) {
                    ctx.fillStyle = foodEaten === 10 ? '#2ecc71' : '#e74c3c';
                    ctx.fillRect(
                        exitDoor.x * cellSize,
                        exitDoor.y * cellSize,
                        exitDoor.width * cellSize,
                        exitDoor.height * cellSize
                    );
                    
                    // Draw door handle
                    ctx.fillStyle = '#f1c40f';
                    ctx.beginPath();
                    ctx.arc(
                        exitDoor.x * cellSize + cellSize/4,
                        exitDoor.y * cellSize + cellSize * 1.5,
                        cellSize/8,
                        Math.PI / 2,
                        Math.PI * 3/2
                    );
                    ctx.fill();
                }
            }
            
            // Update timer
            function updateTimer() {
                if (!gameRunning) return;
                
                gameTime--;
                
                const minutes = Math.floor(gameTime / 60);
                const seconds = gameTime % 60;
                
                timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                if (gameTime <= 0) {
                    endGame("Time's up!");
                }
            }
            
            // End the game
            function endGame(reason, isWin = false) {
                gameRunning = false;
                
                clearInterval(gameInterval);
                clearInterval(crabMoveInterval);
                clearInterval(timerInterval);
                
                // Show game over screen
                gameOver.classList.remove('hidden');
                gameHeader.classList.add('hidden');
                gameCanvas.classList.add('hidden');
                controls.classList.add('hidden');
                
                // Set game over message
                deathReasonElement.textContent = reason;
                finalScoreElement.textContent = score;
                
                if (isWin) {
                    deathReasonElement.style.color = '#2ecc71';
                }
            }
            
            // Start the game
            function startGame() {
                initCanvas();
                initGame();
                
                gameRunning = true;
                
                // Start game interval
                gameInterval = setInterval(update, gameSpeed);
                
                // Start crab movement interval (slower than game update)
                crabMoveInterval = setInterval(moveCrabs, gameSpeed * 3);
                
                // Start timer
                timerInterval = setInterval(updateTimer, 1000);
                
                // Show game elements
                gameHeader.classList.remove('hidden');
                gameCanvas.classList.remove('hidden');
                controls.classList.remove('hidden');
                speedSelection.classList.add('hidden');
            }
            
            // Set game speed
            function setGameSpeed(speed) {
                switch (speed) {
                    case 'slow':
                        gameSpeed = 200;
                        break;
                    case 'medium':
                        gameSpeed = 150;
                        break;
                    case 'fast':
                        gameSpeed = 100;
                        break;
                }
            }
            
            // Event listeners
            startBtn.addEventListener('click', () => {
                instructions.classList.add('hidden');
                speedSelection.classList.remove('hidden');
            });
            
            slowBtn.addEventListener('click', () => {
                setGameSpeed('slow');
                startGame();
            });
            
            mediumBtn.addEventListener('click', () => {
                setGameSpeed('medium');
                startGame();
            });
            
            fastBtn.addEventListener('click', () => {
                setGameSpeed('fast');
                startGame();
            });
            
            playAgainBtn.addEventListener('click', () => {
                gameOver.classList.add('hidden');
                speedSelection.classList.remove('hidden');
            });
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (!gameRunning) return;
                
                switch (e.key) {
                    case 'ArrowUp':
                        if (direction !== 'down') nextDirection = 'up';
                        break;
                    case 'ArrowDown':
                        if (direction !== 'up') nextDirection = 'down';
                        break;
                    case 'ArrowLeft':
                        if (direction !== 'right') nextDirection = 'left';
                        break;
                    case 'ArrowRight':
                        if (direction !== 'left') nextDirection = 'right';
                        break;
                }
            });
            
            // Virtual control buttons
            upBtn.addEventListener('click', () => {
                if (gameRunning && direction !== 'down') nextDirection = 'up';
            });
            
            downBtn.addEventListener('click', () => {
                if (gameRunning && direction !== 'up') nextDirection = 'down';
            });
            
            leftBtn.addEventListener('click', () => {
                if (gameRunning && direction !== 'right') nextDirection = 'left';
            });
            
            rightBtn.addEventListener('click', () => {
                if (gameRunning && direction !== 'left') nextDirection = 'right';
            });
            
            // Initialize canvas size on load and resize
            window.addEventListener('load', initCanvas);
            window.addEventListener('resize', initCanvas);
        });
    </script>
</body>
</html>
